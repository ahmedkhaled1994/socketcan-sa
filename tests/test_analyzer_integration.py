#!/usr/bin/env python3
"""
Integration tests for analyzer.py with real SocketCAN interfaces

These tests use actual vcan (virtual CAN) interfaces to validate:
- Real CAN frame processing
- Accurate statistics calculation  
- Bus load measurements
- CSV export with real data
- Multi-interface scenarios
- Performance under realistic conditions

Requires: vcan0 and vcan1 interfaces (setup via tools/setup_vcan.sh)
"""

import pytest
import subprocess
import time
import tempfile
import csv
import os
import threading
from pathlib import Path
from socketcan_sa.analyzer import analyze

# Skip integration tests if not in WSL/Linux environment
try:
    subprocess.run(['ip', 'link', 'show', 'vcan0'], 
                   check=True, capture_output=True, text=True)
    HAS_VCAN = True
except (subprocess.CalledProcessError, FileNotFoundError):
    HAS_VCAN = False

pytestmark = pytest.mark.skipif(not HAS_VCAN, reason="vcan interfaces not available")


class TestAnalyzerVcanIntegration:
    """Integration tests using real vcan interfaces."""
    
    @pytest.mark.integration
    @pytest.mark.timeout(30)
    def test_analyzer_with_real_can_traffic(self):
        """
        Test analyzer with real CAN traffic generated by cangen.
        
        This test validates:
        - Real frame reception and processing
        - Statistics accuracy with known traffic patterns
        - Console output formatting
        - Proper resource cleanup
        """
        # Setup: ensure vcan0 is available
        try:
            subprocess.run(['ip', 'link', 'show', 'vcan0'], 
                          check=True, capture_output=True)
        except subprocess.CalledProcessError:
            pytest.skip("vcan0 interface not available")
        
        # Generate known CAN traffic pattern
        # cangen: generate 50 frames with ID 0x123, 4 bytes payload, 100ms intervals
        cangen_cmd = [
            'cangen', 'vcan0', 
            '-I', '123',      # Fixed CAN ID 0x123
            '-L', '4',        # 4-byte payload  
            '-D', 'i',        # Incremental data
            '-g', '100',      # 100ms gap between frames
            '-n', '20'        # Generate 20 frames
        ]
        
        # Start traffic generation in background
        traffic_proc = subprocess.Popen(cangen_cmd, 
                                       stdout=subprocess.PIPE, 
                                       stderr=subprocess.PIPE)
        
        # Run analyzer for 3 seconds to capture traffic
        analyzer_stop = threading.Event()
        
        def run_analyzer():
            try:
                analyze("vcan0", interval=1.0, bitrate=500_000, 
                       quiet=False, stop_event=analyzer_stop)
            except Exception as e:
                print(f"Analyzer error: {e}")
        
        analyzer_thread = threading.Thread(target=run_analyzer)
        analyzer_thread.start()
        
        # Let analyzer run for 3 seconds
        time.sleep(3.0)
        
        # Stop analyzer and traffic generation
        analyzer_stop.set()
        traffic_proc.terminate()
        
        # Wait for completion
        analyzer_thread.join(timeout=5.0)
        traffic_proc.wait(timeout=5.0)
        
        # Verify no exceptions occurred (successful completion)
        assert not analyzer_thread.is_alive(), "Analyzer thread should have stopped"
        
    @pytest.mark.integration 
    @pytest.mark.timeout(45)
    def test_analyzer_csv_export_with_real_data(self):
        """
        Test CSV export functionality with real CAN traffic.
        
        Validates:
        - CSV file creation and structure
        - Data accuracy in CSV output
        - Multiple CAN IDs in CSV
        - Proper CSV formatting
        """
        # Setup temporary CSV file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as tmp_csv:
            csv_path = tmp_csv.name
        
        try:
            # Generate diverse CAN traffic
            # Multiple IDs with different data lengths
            traffic_cmds = [
                ['cangen', 'vcan0', '-I', '100', '-L', '2', '-g', '50', '-n', '10'],
                ['cangen', 'vcan0', '-I', '200', '-L', '8', '-g', '80', '-n', '8'],
                ['cangen', 'vcan0', '-I', '300', '-L', '1', '-g', '120', '-n', '6']
            ]
            
            # Start all traffic generators
            traffic_procs = []
            for cmd in traffic_cmds:
                proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                traffic_procs.append(proc)
                time.sleep(0.1)  # Stagger starts
            
            # Run analyzer with CSV export
            analyzer_stop = threading.Event()
            
            def run_analyzer_csv():
                try:
                    analyze("vcan0", interval=2.0, bitrate=500_000, 
                           csv_path=csv_path, quiet=True, stop_event=analyzer_stop)
                except Exception as e:
                    print(f"Analyzer CSV error: {e}")
            
            analyzer_thread = threading.Thread(target=run_analyzer_csv)
            analyzer_thread.start()
            
            # Let analysis run for 5 seconds
            time.sleep(5.0)
            
            # Stop everything
            analyzer_stop.set()
            for proc in traffic_procs:
                proc.terminate()
            
            # Wait for completion
            analyzer_thread.join(timeout=10.0)
            for proc in traffic_procs:
                proc.wait(timeout=5.0)
            
            # Verify CSV file was created and has content
            assert os.path.exists(csv_path), "CSV file should be created"
            assert os.path.getsize(csv_path) > 0, "CSV file should have content"
            
            # Validate CSV structure and content
            with open(csv_path, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                rows = list(reader)
                
                # Should have at least some data rows
                assert len(rows) > 0, "CSV should contain data rows"
                
                # Verify CSV header structure
                expected_headers = ["ts_unix", "iface", "bus_load_pct", "id_hex", 
                                  "fps", "avg_jitter_ms", "avg_len_bytes", "count"]
                assert reader.fieldnames == expected_headers, "CSV headers should match expected format"
                
                # Verify we captured multiple CAN IDs
                can_ids = {row['id_hex'] for row in rows}
                assert len(can_ids) >= 2, f"Should capture multiple CAN IDs, got: {can_ids}"
                
                # Verify data types and ranges
                for row in rows:
                    assert row['iface'] == 'vcan0', "Interface should be vcan0"
                    assert 0 <= float(row['bus_load_pct']) <= 100, "Bus load should be 0-100%"
                    assert float(row['fps']) >= 0, "FPS should be non-negative"
                    assert float(row['avg_jitter_ms']) >= 0, "Jitter should be non-negative"
                    assert 0 <= float(row['avg_len_bytes']) <= 8, "Average length should be 0-8 bytes"
                    assert int(row['count']) > 0, "Frame count should be positive"
        
        finally:
            # Cleanup temporary file
            if os.path.exists(csv_path):
                os.unlink(csv_path)
    
    @pytest.mark.integration
    @pytest.mark.timeout(30)
    def test_analyzer_bus_load_accuracy(self):
        """
        Test bus load calculation accuracy with known traffic patterns.
        
        Validates:
        - Bus load percentage calculation
        - Different bitrate scenarios
        - Load calculation with varying frame sizes
        """
        # Test with low bitrate for easier validation
        test_bitrate = 10_000  # 10 kbps for easy calculation
        
        # Generate precisely timed traffic
        # Single frame: 4 bytes = 47 + 32 = 79 bits
        # At 100ms intervals = 10 Hz = 790 bits/sec
        # Expected load: 790/10000 = 7.9%
        cangen_cmd = [
            'cangen', 'vcan0',
            '-I', '123',      # Fixed ID
            '-L', '4',        # 4-byte payload (79 bits total)
            '-g', '100',      # 100ms intervals (10 Hz)
            '-n', '30'        # 30 frames over 3 seconds
        ]
        
        traffic_proc = subprocess.Popen(cangen_cmd,
                                       stdout=subprocess.PIPE,
                                       stderr=subprocess.PIPE)
        
        # Capture analyzer output to validate bus load calculation
        analyzer_stop = threading.Event()
        captured_output = []
        
        def run_analyzer_capture():
            import io
            import contextlib
            from unittest.mock import patch
            
            output_buffer = io.StringIO()
            
            try:
                with patch('builtins.print') as mock_print:
                    def capture_print(*args, **kwargs):
                        print(*args, **kwargs, file=output_buffer)
                        mock_print(*args, **kwargs)
                    
                    with patch('builtins.print', side_effect=capture_print):
                        analyze("vcan0", interval=2.0, bitrate=test_bitrate,
                               quiet=False, stop_event=analyzer_stop)
            except Exception as e:
                print(f"Analyzer capture error: {e}")
            finally:
                captured_output.append(output_buffer.getvalue())
        
        analyzer_thread = threading.Thread(target=run_analyzer_capture)
        analyzer_thread.start()
        
        # Let analysis run for 4 seconds
        time.sleep(4.0)
        
        # Stop everything  
        analyzer_stop.set()
        traffic_proc.terminate()
        
        # Wait for completion
        analyzer_thread.join(timeout=10.0)
        traffic_proc.wait(timeout=5.0)
        
        # Analyze captured output for bus load values
        if captured_output:
            output_text = captured_output[0]
            print(f"Captured analyzer output:\n{output_text}")
            
            # Look for bus load percentages in output
            # Expected: around 7-8% based on our calculation
            import re
            load_matches = re.findall(r'bus_load≈(\d+\.?\d*)%', output_text)
            
            if load_matches:
                bus_loads = [float(load) for load in load_matches]
                avg_load = sum(bus_loads) / len(bus_loads)
                
                # Verify load is in reasonable range (5-15% accounting for timing variations)
                assert 2.0 <= avg_load <= 20.0, f"Bus load {avg_load:.1f}% should be in reasonable range"
                print(f"✅ Bus load calculation validated: {avg_load:.1f}%")
            else:
                print("⚠️  No bus load values found in output (test may need more time)")
    
    @pytest.mark.integration
    @pytest.mark.timeout(20)
    def test_analyzer_multi_interface_isolation(self):
        """
        Test that analyzer correctly isolates traffic from specific interface.
        
        Validates:
        - Interface-specific traffic capture
        - No cross-contamination between interfaces
        - Proper interface selection
        """
        # Generate traffic on vcan1 (should not be captured by vcan0 analyzer)
        try:
            subprocess.run(['ip', 'link', 'show', 'vcan1'], 
                          check=True, capture_output=True)
        except subprocess.CalledProcessError:
            pytest.skip("vcan1 interface not available")
        
        # Traffic on vcan1 (should NOT be captured)
        vcan1_traffic = subprocess.Popen([
            'cangen', 'vcan1', '-I', '999', '-L', '8', '-g', '50', '-n', '20'
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Small amount of traffic on vcan0 (SHOULD be captured)
        vcan0_traffic = subprocess.Popen([
            'cangen', 'vcan0', '-I', '123', '-L', '4', '-g', '200', '-n', '5'  
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Run analyzer on vcan0 only
        analyzer_stop = threading.Event()
        captured_ids = []
        
        def run_analyzer_isolation():
            import io
            from unittest.mock import patch
            
            output_buffer = io.StringIO()
            
            try:
                with patch('builtins.print') as mock_print:
                    def capture_print(*args, **kwargs):
                        line = ' '.join(str(arg) for arg in args)
                        if 'ID=0x' in line:
                            # Extract CAN ID from output
                            import re
                            id_match = re.search(r'ID=0x([0-9A-F]+)', line)
                            if id_match:
                                captured_ids.append(id_match.group(1))
                        print(*args, **kwargs, file=output_buffer)
                        mock_print(*args, **kwargs)
                    
                    with patch('builtins.print', side_effect=capture_print):
                        analyze("vcan0", interval=1.0, bitrate=500_000,
                               quiet=False, stop_event=analyzer_stop)
            except Exception as e:
                print(f"Analyzer isolation error: {e}")
        
        analyzer_thread = threading.Thread(target=run_analyzer_isolation)
        analyzer_thread.start()
        
        # Let analysis run for 3 seconds
        time.sleep(3.0)
        
        # Stop everything
        analyzer_stop.set()
        vcan0_traffic.terminate()
        vcan1_traffic.terminate()
        
        # Wait for completion
        analyzer_thread.join(timeout=10.0)
        vcan0_traffic.wait(timeout=5.0)
        vcan1_traffic.wait(timeout=5.0)
        
        # Verify interface isolation
        if captured_ids:
            # Should only see ID 123 from vcan0, never ID 999 from vcan1
            unique_ids = set(captured_ids)
            assert '123' in unique_ids, "Should capture traffic from vcan0 (ID 123)"
            assert '999' not in unique_ids, "Should NOT capture traffic from vcan1 (ID 999)"
            assert '3E7' not in unique_ids, "Should NOT capture traffic from vcan1 (ID 999 = 0x3E7)"
            print(f"✅ Interface isolation validated. Captured IDs: {unique_ids}")
        else:
            print("⚠️  No CAN IDs captured (test may need adjustment)")


class TestAnalyzerRealWorldScenarios:
    """Test analyzer behavior in realistic CAN network scenarios."""
    
    @pytest.mark.integration
    @pytest.mark.timeout(60)
    def test_analyzer_automotive_simulation(self):
        """
        Simulate realistic automotive CAN traffic patterns.
        
        Tests:
        - Mixed periodic and event-driven messages
        - Various message priorities and frequencies
        - Realistic bus loading scenarios
        """
        # Skip if vcan not available
        if not HAS_VCAN:
            pytest.skip("vcan interfaces not available")
        
        # Simulate automotive ECU traffic patterns
        traffic_patterns = [
            # Engine RPM (high frequency, small payload)
            ['cangen', 'vcan0', '-I', '201', '-L', '2', '-g', '10', '-n', '100'],  # 100 Hz
            
            # Vehicle speed (medium frequency)  
            ['cangen', 'vcan0', '-I', '420', '-L', '4', '-g', '50', '-n', '40'],   # 20 Hz
            
            # Door status (event-driven, low frequency)
            ['cangen', 'vcan0', '-I', '635', '-L', '1', '-g', '500', '-n', '4'],   # 2 Hz
            
            # Diagnostic messages (sporadic, full payload)
            ['cangen', 'vcan0', '-I', '7DF', '-L', '8', '-g', '1000', '-n', '2']   # 1 Hz
        ]
        
        # Start all traffic simulators
        traffic_procs = []
        for pattern in traffic_patterns:
            proc = subprocess.Popen(pattern, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            traffic_procs.append(proc)
            time.sleep(0.05)  # Stagger starts slightly
        
        # Create temporary CSV for detailed analysis
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as tmp_csv:
            csv_path = tmp_csv.name
        
        try:
            # Run analyzer for 5 seconds to capture realistic patterns
            analyzer_stop = threading.Event()
            
            def run_automotive_analyzer():
                try:
                    analyze("vcan0", interval=1.0, bitrate=500_000,
                           csv_path=csv_path, quiet=False, stop_event=analyzer_stop)
                except Exception as e:
                    print(f"Automotive analyzer error: {e}")
            
            analyzer_thread = threading.Thread(target=run_automotive_analyzer)
            analyzer_thread.start()
            
            # Let realistic traffic run for 5 seconds
            time.sleep(5.0)
            
            # Stop all traffic and analyzer
            analyzer_stop.set()
            for proc in traffic_procs:
                proc.terminate()
            
            # Wait for completion
            analyzer_thread.join(timeout=10.0)
            for proc in traffic_procs:
                proc.wait(timeout=5.0)
            
            # Analyze results for realistic behavior
            if os.path.exists(csv_path) and os.path.getsize(csv_path) > 0:
                with open(csv_path, 'r', newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    rows = list(reader)
                    
                    if rows:
                        # Group by CAN ID to analyze per-message statistics
                        id_stats = {}
                        for row in rows:
                            can_id = row['id_hex']
                            if can_id not in id_stats:
                                id_stats[can_id] = []
                            id_stats[can_id].append(row)
                        
                        print(f"✅ Captured {len(rows)} data points for {len(id_stats)} CAN IDs")
                        print(f"CAN IDs detected: {list(id_stats.keys())}")
                        
                        # Verify we captured multiple expected IDs (in hex)
                        expected_ids = {'0x201', '0x420', '0x635', '0x7DF'}  # Our test IDs
                        captured_ids = set(id_stats.keys())
                        
                        # Should capture at least some of our test traffic
                        intersection = expected_ids.intersection(captured_ids)
                        assert len(intersection) >= 1, f"Should capture some expected IDs. Got: {captured_ids}"
                        
                        print(f"✅ Automotive simulation validated with IDs: {intersection}")
                    else:
                        print("⚠️  No CSV data captured (timing may need adjustment)")
            else:
                print("⚠️  CSV file not created or empty")
        
        finally:
            # Cleanup
            if os.path.exists(csv_path):
                os.unlink(csv_path)